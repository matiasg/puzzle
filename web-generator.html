<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Puzzle Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }

        input[type="file"], input[type="number"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }

        input[type="number"] {
            width: 100px;
        }

        .grid-inputs {
            display: flex;
            gap: 20px;
        }

        button {
            background-color: #007bff;
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            display: block;
            margin: 20px auto;
        }

        button:hover {
            background-color: #0056b3;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .preview {
            margin-top: 20px;
            text-align: center;
        }

        #imagePreview {
            max-width: 100%;
            max-height: 300px;
            border: 2px solid #ddd;
            border-radius: 5px;
        }

        .output {
            margin-top: 20px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border: 1px solid #dee2e6;
        }

        .output h3 {
            margin-top: 0;
            color: #333;
        }

        .progress {
            margin-top: 20px;
            text-align: center;
            font-weight: bold;
            color: #007bff;
        }

        .error {
            color: #dc3545;
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }

        .success {
            color: #155724;
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ§© Web Puzzle Generator</h1>

        <div class="form-group">
            <label for="imageInput">Select Image:</label>
            <input type="file" id="imageInput" accept="image/*">
        </div>

        <div class="form-group">
            <label>Puzzle Grid Size:</label>
            <div class="grid-inputs">
                <div>
                    <label for="columns">Columns:</label>
                    <input type="number" id="columns" value="3" min="2" max="10">
                </div>
                <div>
                    <label for="rows">Rows:</label>
                    <input type="number" id="rows" value="2" min="2" max="10">
                </div>
            </div>
        </div>

        <div class="form-group">
            <label>
                <input type="checkbox" id="showNumbers"> Show piece numbers
            </label>
            <small style="display: block; color: #666; margin-top: 5px;">
                Display numbers on puzzle pieces for easier identification
            </small>
        </div>

        <button id="generateBtn" disabled>Generate Puzzle</button>

        <div class="preview">
            <img id="imagePreview" style="display: none;">
        </div>

        <div id="progress" class="progress" style="display: none;"></div>
        <div id="error" class="error" style="display: none;"></div>
        <div id="success" class="success" style="display: none;"></div>

        <div id="output" class="output" style="display: none;">
            <h3>ðŸ“¥ Download Puzzle Files</h3>
            <p><strong>All files</strong> - Puzzle configuration and all piece SVGs</p>
            <button id="downloadAllBtn" style="margin-top: 10px;">ðŸ“¦ Download All Files (ZIP)</button>
        </div>
    </div>

    <script>
        class WebPuzzleGenerator {
            constructor() {
                this.imageFile = null;
                this.imageData = null;
                this.pieceWidth = 100;
                this.pieceHeight = 100;
                this.tabSize = 20;
                this.tabPattern = null; // Will store consistent pattern
                this.init();
            }

            init() {
                const imageInput = document.getElementById('imageInput');
                const generateBtn = document.getElementById('generateBtn');

                imageInput.addEventListener('change', (e) => this.handleImageSelect(e));
                generateBtn.addEventListener('click', () => this.generatePuzzle());
            }

            handleImageSelect(event) {
                const file = event.target.files[0];
                if (!file) return;

                this.imageFile = file;

                const reader = new FileReader();
                reader.onload = (e) => {
                    this.imageData = e.target.result;
                    this.showPreview();
                    document.getElementById('generateBtn').disabled = false;
                };
                reader.readAsDataURL(file);
            }

            showPreview() {
                const preview = document.getElementById('imagePreview');
                preview.src = this.imageData;
                preview.style.display = 'block';
            }

            async generatePuzzle() {
                if (!this.imageData) return;

                const cols = parseInt(document.getElementById('columns').value);
                const rows = parseInt(document.getElementById('rows').value);
                const showNumbers = document.getElementById('showNumbers').checked;

                this.showProgress(`Generating ${cols}Ã—${rows} puzzle...`);
                this.hideMessages();

                // Generate consistent tab pattern
                this.tabPattern = this.generateTabPattern(cols, rows);

                try {
                    // Load image
                    const img = new Image();
                    await new Promise((resolve) => {
                        img.onload = resolve;
                        img.src = this.imageData;
                    });

                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');

                    canvas.width = cols * this.pieceWidth;
                    canvas.height = rows * this.pieceHeight;

                    // Draw and scale image
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                    const pieces = [];

                    // Generate pieces
                    for (let row = 0; row < rows; row++) {
                        for (let col = 0; col < cols; col++) {
                            const pieceIndex = row * cols + col;
                            this.showProgress(`Creating piece ${pieceIndex + 1} of ${cols * rows}...`);

                            const piece = await this.createPiece(ctx, col, row, pieceIndex, cols, rows, showNumbers);
                            pieces.push(piece);
                        }
                    }

                    // Generate downloads
                    this.generateDownloads(pieces, cols, rows);
                    this.showSuccess(`âœ… Puzzle generated successfully! ${pieces.length} pieces created.`);

                } catch (error) {
                    this.showError(`Error: ${error.message}`);
                    console.error('Generation error:', error);
                }
            }

            async createPiece(sourceCtx, col, row, index, cols, rows, showNumbers) {
                const canvas = document.createElement('canvas');
                canvas.width = this.pieceWidth;
                canvas.height = this.pieceHeight;
                const ctx = canvas.getContext('2d');

                const x = col * this.pieceWidth;
                const y = row * this.pieceHeight;

                // Save the context state
                ctx.save();

                // Create clipping path
                ctx.beginPath();
                ctx.rect(0, 0, this.pieceWidth, this.pieceHeight);

                // Use consistent tab pattern from pre-generated array
                const pattern = this.tabPattern[row][col];
                const hasTopTab = pattern.top;
                const hasRightTab = pattern.right;
                const hasBottomTab = pattern.bottom;
                const hasLeftTab = pattern.left;

                // Draw tabs
                if (hasTopTab) this.drawTab(ctx, 'top', true);
                else if (row > 0) this.drawTab(ctx, 'top', false);

                if (hasRightTab) this.drawTab(ctx, 'right', true);
                else if (col < cols - 1) this.drawTab(ctx, 'right', false);

                if (hasBottomTab) this.drawTab(ctx, 'bottom', true);
                else if (row < rows - 1) this.drawTab(ctx, 'bottom', false);

                if (hasLeftTab) this.drawTab(ctx, 'left', true);
                else if (col > 0) this.drawTab(ctx, 'left', false);

                ctx.clip();

                // Draw the image portion
                ctx.drawImage(sourceCtx.canvas, x, y, this.pieceWidth, this.pieceHeight, 0, 0, this.pieceWidth, this.pieceHeight);

                ctx.restore();

                // Add border
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Add piece number only if showNumbers is true
                if (showNumbers) {
                    ctx.fillStyle = 'white';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 1;
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.strokeText((index + 1).toString(), this.pieceWidth/2, this.pieceHeight/2);
                    ctx.fillText((index + 1).toString(), this.pieceWidth/2, this.pieceHeight/2);
                }

                return {
                    file: `piece${index + 1}.svg`,
                    x: x + this.pieceWidth / 2,
                    y: y + this.pieceHeight / 2,
                    svgData: this.canvasToSVG(canvas, index + 1)
                };
            }

            drawTab(ctx, side, isTab) {
                const tabWidth = this.tabSize;
                const tabHeight = this.tabSize / 2;
                const centerX = this.pieceWidth / 2;
                const centerY = this.pieceHeight / 2;

                ctx.save();

                if (side === 'top') {
                    const tabX = centerX;
                    if (isTab) {
                        ctx.moveTo(tabX - tabWidth/2, 0);
                        ctx.quadraticCurveTo(tabX - tabWidth/2, -tabHeight, tabX, -tabHeight);
                        ctx.quadraticCurveTo(tabX + tabWidth/2, -tabHeight, tabX + tabWidth/2, 0);
                    } else {
                        ctx.moveTo(tabX - tabWidth/2, 0);
                        ctx.quadraticCurveTo(tabX - tabWidth/2, tabHeight, tabX, tabHeight);
                        ctx.quadraticCurveTo(tabX + tabWidth/2, tabHeight, tabX + tabWidth/2, 0);
                    }
                } else if (side === 'right') {
                    const tabY = centerY;
                    if (isTab) {
                        ctx.moveTo(this.pieceWidth, tabY - tabWidth/2);
                        ctx.quadraticCurveTo(this.pieceWidth + tabHeight, tabY - tabWidth/2, this.pieceWidth + tabHeight, tabY);
                        ctx.quadraticCurveTo(this.pieceWidth + tabHeight, tabY + tabWidth/2, this.pieceWidth, tabY + tabWidth/2);
                    } else {
                        ctx.moveTo(this.pieceWidth, tabY - tabWidth/2);
                        ctx.quadraticCurveTo(this.pieceWidth - tabHeight, tabY - tabWidth/2, this.pieceWidth - tabHeight, tabY);
                        ctx.quadraticCurveTo(this.pieceWidth - tabHeight, tabY + tabWidth/2, this.pieceWidth, tabY + tabWidth/2);
                    }
                } else if (side === 'bottom') {
                    const tabX = centerX;
                    if (isTab) {
                        ctx.moveTo(tabX + tabWidth/2, this.pieceHeight);
                        ctx.quadraticCurveTo(tabX + tabWidth/2, this.pieceHeight + tabHeight, tabX, this.pieceHeight + tabHeight);
                        ctx.quadraticCurveTo(tabX - tabWidth/2, this.pieceHeight + tabHeight, tabX - tabWidth/2, this.pieceHeight);
                    } else {
                        ctx.moveTo(tabX + tabWidth/2, this.pieceHeight);
                        ctx.quadraticCurveTo(tabX + tabWidth/2, this.pieceHeight - tabHeight, tabX, this.pieceHeight - tabHeight);
                        ctx.quadraticCurveTo(tabX - tabWidth/2, this.pieceHeight - tabHeight, tabX - tabWidth/2, this.pieceHeight);
                    }
                } else if (side === 'left') {
                    const tabY = centerY;
                    if (isTab) {
                        ctx.moveTo(0, tabY + tabWidth/2);
                        ctx.quadraticCurveTo(-tabHeight, tabY + tabWidth/2, -tabHeight, tabY);
                        ctx.quadraticCurveTo(-tabHeight, tabY - tabWidth/2, 0, tabY - tabWidth/2);
                    } else {
                        ctx.moveTo(0, tabY + tabWidth/2);
                        ctx.quadraticCurveTo(tabHeight, tabY + tabWidth/2, tabHeight, tabY);
                        ctx.quadraticCurveTo(tabHeight, tabY - tabWidth/2, 0, tabY - tabWidth/2);
                    }
                }

                ctx.restore();
            }

            canvasToSVG(canvas, pieceNumber) {
                const dataURL = canvas.toDataURL();
                return `<svg width="${this.pieceWidth}" height="${this.pieceHeight}" viewBox="0 0 ${this.pieceWidth} ${this.pieceHeight}" xmlns="http://www.w3.org/2000/svg">
    <image href="${dataURL}" x="0" y="0" width="${this.pieceWidth}" height="${this.pieceHeight}"/>
</svg>`;
            }

            generateTabPattern(cols, rows) {
                // Generate a consistent 2D array for tab/blank patterns
                // true = tab (external lobe), false = blank (internal hole)
                const pattern = [];

                // First, create empty pattern
                for (let row = 0; row < rows; row++) {
                    pattern[row] = [];
                    for (let col = 0; col < cols; col++) {
                        pattern[row][col] = {
                            top: null,
                            right: null,
                            bottom: null,
                            left: null
                        };
                    }
                }

                // Now assign tabs/blanks for each edge connection
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const pieceIndex = row * cols + col;

                        // For each edge connection, decide which piece gets the tab
                        // Horizontal connections (left-right)
                        if (col < cols - 1) {
                            const hasTab = (pieceIndex + col) % 2 === 0;
                            pattern[row][col].right = hasTab;        // This piece gets tab on right
                            pattern[row][col + 1].left = !hasTab;    // Right piece gets blank on left
                        }

                        // Vertical connections (top-bottom)
                        if (row < rows - 1) {
                            const hasTab = (pieceIndex + row) % 2 === 1;
                            pattern[row][col].bottom = hasTab;       // This piece gets tab on bottom
                            pattern[row + 1][col].top = !hasTab;     // Bottom piece gets blank on top
                        }
                    }
                }

                return pattern;
            }

            generateDownloads(pieces, cols, rows) {
                const outputDiv = document.getElementById('output');
                const downloadBtn = document.getElementById('downloadAllBtn');

                // Create puzzle.json
                const puzzleData = pieces.map(piece => ({
                    file: piece.file,
                    x: piece.x,
                    y: piece.y
                }));
                const puzzleJSON = JSON.stringify(puzzleData, null, 2);

                // Create ZIP file
                const zip = new JSZip();

                // Add puzzle.json to ZIP
                zip.file('puzzle.json', puzzleJSON);

                // Add all SVG files to ZIP
                pieces.forEach(piece => {
                    zip.file(piece.file, piece.svgData);
                });

                // Set up download button
                downloadBtn.onclick = async () => {
                    try {
                        const blob = await zip.generateAsync({ type: 'blob' });
                        const url = URL.createObjectURL(blob);

                        const link = document.createElement('a');
                        link.href = url;
                        link.download = 'puzzle-files.zip';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);

                        setTimeout(() => URL.revokeObjectURL(url), 100);
                    } catch (error) {
                        this.showError(`Error creating ZIP: ${error.message}`);
                    }
                };

                outputDiv.style.display = 'block';
            }

            showProgress(message) {
                const progress = document.getElementById('progress');
                progress.textContent = message;
                progress.style.display = 'block';
            }

            showError(message) {
                const error = document.getElementById('error');
                error.textContent = message;
                error.style.display = 'block';
                document.getElementById('progress').style.display = 'none';
            }

            showSuccess(message) {
                const success = document.getElementById('success');
                success.textContent = message;
                success.style.display = 'block';
                document.getElementById('progress').style.display = 'none';
            }

            hideMessages() {
                document.getElementById('error').style.display = 'none';
                document.getElementById('success').style.display = 'none';
                document.getElementById('progress').style.display = 'none';
            }
        }

        // Initialize the generator
        document.addEventListener('DOMContentLoaded', () => {
            new WebPuzzleGenerator();
        });
    </script>
</body>
</html>